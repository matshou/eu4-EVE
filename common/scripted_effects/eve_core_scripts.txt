
##################################
# EVE - Core Scripts
##################################

# List of flags:
# ====================
#  eve_initialized			# global
#  found_country			# global
#  inagurated				# ruler
#  immediate_update			# country
#  is_initialized			# country
#  territorial_change		# country
#  gained_new_territory		# country
#  new_territory			# province
#  conquered_capital		# province
#  distant_province			# province


# List of variables:
# ====================
#  last_month				# last month that pulse fired
#  country_id				# used as substitude for 'province_id'
#  owner_id					# used by provinces to pair with 'country_id'


# When called monthly pulse will fire next day in capital province
# @scope country
#
core.fire_monthly_pulse = {
	set_country_flag = immediate_update
}

# Called once every day for each country
# @scope country
#
core.on_daily_pulse = {

	# This triggers when the capital gets moved to another
	# province or the previous owner gets annexed
	if = {
		limit = { ROOT = { is_not_capital = yes } }
		ROOT = { capital.lose_status = yes }
	}
	# Don't do anything else if no longer a capital province
	else = {
		# Check if a new ruler has rised to throne
		if = {
			limit = { has_new_ruler = yes }

			set_ruler_flag = inagurated
			calc_gov_policy_ruler_mod = yes
		}
		if = {
			limit = { should_do_monthly_update = yes }
			core.on_monthly_pulse = yes
		}
	}
}

# This fires once each month, use it to handle monthly updates
# @scope country
#
core.on_monthly_pulse = {

	export_to_variable = {
		which = last_month
		value = trigger_value:is_month
	}
	if = {
		limit = { has_country_flag = immediate_update }
		clr_country_flag = immediate_update
	}

	# Triggers only for player, do all GLOBAL stuff here:
	if = {
		limit = { is_global_scope = yes }

		# Check on each pulse to see if a new country formed
		every_country = {
			limit = { is_country_initialized = no }
			core.init_country = yes
		}
	}

	update_all_states = yes
	update_non_state_provinces = yes
	update_gov_policy = yes
	autonomy.check_for_change = yes

	# Owner has gained new territory or changed capital province
	if = {
		limit = { has_territorial_changes = yes }
		autonomy.update_distance = yes
	}
}

# Assign country and province id's and enable monthly pulse for scoped country.
# This is called in mod init phase and when a new country is formed
# @scope country
#
core.init_country = {

	if = {
		# can only be called once per country
		limit = { is_country_initialized = no }

		core.set_country_id = yes
		every_owned_province = {
			core.set_prov_owner_id = yes
		}

		capital.init = yes						# apply capital modifiers
		core.fire_monthly_pulse = yes    		# force an immediate update
		init_domestic_policies = yes

		set_country_flag = is_initialized
		set_country_flag = territorial_change
	}
}

# Assign a unique id for scoped country.
# Should ONLY be called from global scope!
# @scope country
#
core.set_country_id = {

	if = {
		limit = { PREV = { is_global_scope = yes } }

		PREV = { core.export_var_to_prev = { var = init_num } }
		set_variable = { which = country_id which = output_var }

		PREV = { change_variable = { which = init_num value = 1 } }
		change_variable = { which = country_id value = 1 }
	}
	else = { core.print_error = { code = 199 } }
}

# Assign a unique id for province that coresponds to owner country id
# Each owned province should ALWAYS have the same id as its current owner
# @scope country
#
core.set_prov_owner_id = {

	owner = {
		if = {
			limit = { check_variable = { which = country_id value = 1 } }
			core.export_var_to_prev = { var = country_id }
			PREV = { set_variable = { which = owner_id which = output_var } }
		}
		else = { core.print_error = { code = 279 } }
	}
}

# Export argument variable to PREV scope so it can be used for comparison.
# Currently performing an interlaced scan with intervals using while loops
# is the only way to transfer variable values between scopes.
# @scope anywhere
# @param var (variable to export)
# @return output_var
#
core.export_var_to_prev = {

	set_variable = { which = counter_var value = 1000 }
	PREV = { set_variable = { which = output_var value = 1000 } }

	# Do an interlaced scan alternating between adding and subtracting,
	# until we find an approximate value that we can use in a final loop

	while = {
		limit = {
			is_var_greater_than = { var1 = $var$ var2 = counter_var }
		}
		change_variable = { which = counter_var value = 1000 }
		PREV = { change_variable = { which = output_var value = 1000 } }
	}
	while = {
		limit = {
			is_var_less_than = { var1 = $var$ var2 = counter_var }
		}
		subtract_variable = { which = counter_var value = 100 }
		PREV = { subtract_variable = { which = output_var value = 100 } }
	}
	while = {
		limit = {
			is_var_greater_than = { var1 = $var$ var2 = counter_var }
		}
		change_variable = { which = counter_var value = 10 }
		PREV = { change_variable = { which = output_var value = 10 } }
	}

	while = {
		limit = { is_var_not_equal_to = { var1 = counter_var var2 = $var$ } }
		subtract_variable = { which = counter_var value = 1 }
		PREV = { subtract_variable = { which = output_var value = 1 } }
	}
}

# Helper method to print error messages in game log
# Strings are stored in localization files
# @scope anywhere
#
core.print_error = {

	event_target:global = {
		set_variable = { which = error_code value = $code$ }
		PREV = { log = "EVE: Error [Prev.error_code.GetValue] >> [This.error_log_txt]" }
	}
