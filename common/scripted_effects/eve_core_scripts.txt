
##################################
# EVE - Core Scripts
##################################

# List of flags:
# ====================
#  eve_initialized			# global
#  found_country			# global
#  inagurated				# ruler
#  immediate_update			# country
#  is_initialized			# country
#  territorial_change		# country
#  gained_new_territory		# country
#  new_territory			# province
#  conquered_capital		# province
#  distant_province			# province


# List of variables:
# ====================
#  counter_var				# used for while loops
#  counter2_var				# -||-
#  output_var				# used for methods that create output
#  last_month				# last month that monthly pulse fired
#  country_id				# used as substitude for 'province_id'
#  owner_id					# used by provinces to pair with 'country_id'


# Scope: country
# The monthly pulse will fire the NEXT day in capital province
#
core.fire_monthly_pulse = {
	set_country_flag = immediate_update
}

# Scope: country
# Fires once each day from 'capital_province' method
#
core.on_daily_pulse = {

	# This triggers when the capital gets moved to another
	# province or the previous owner gets annexed
	if = {
		limit = { ROOT = { is_not_capital = yes } }
		ROOT = { core.no_longer_capital = yes }
	}
	# Don't do anything else if no longer a capital province
	else = {
		# Check if a new ruler has rised to throne
		if = {
			limit = { has_new_ruler = yes }

			set_ruler_flag = inagurated
			export_ruler_skills = yes
			calc_gov_policy_ruler_mod = yes
		}
		if = {
			limit = { should_do_monthly_update = yes }
			core.on_monthly_pulse = yes
		}
	}
}

# Scope: country
# This fires once each month, use it to handle stuff that depend on monthly updates
# Note: ROOT scope here is the province caller. This is very useful for using vanilla
#		methods that only accept scope as argument (example: 'province_distance' condition)
#
core.on_monthly_pulse = {

	export_to_variable = { which = last_month value = trigger_value:is_month }
	if = {
		limit = { has_country_flag = immediate_update }
		clr_country_flag = immediate_update
	}

	# Triggers only for player, do all GLOBAL stuff here:
	if = {
		limit = { is_global_scope = yes }

		# Check on each pulse to see if a new country formed
		every_country = {
			limit = { is_country_initialized = no }
			core.init_country = yes
		}
	}

	update_all_states = yes
	update_non_state_provinces = yes
	update_gov_policy = yes
	autonomy.check_for_change = yes

	# Owner country has either gained new territory
	# or changed its capital province
	if = {
		limit = { has_territorial_changes = yes }
		autonomy.update_distance = yes
	}
}

# Scope: province
# Fired from province that stops being a nation's capital
#
core.no_longer_capital = {

	capital.remove_modifiers = yes

	owner = {
		ROOT = { core.export_var_to_prev = { VAR = owner_id } }

		# This province was gained as a concession in a war or
		# for other reasons has ended up as territory of another country
		if = {
			limit = { is_var_not_equal_to = { VAR1 = output_var VAR2 = country_id } }

			# Find capital province previous owner.
			# Normally we would do this by using 'previous_owner' variable,
			# but for some reason it gets set to null after loading a campaign

			every_known_country = {
				limit = {
					# output variable will be set to -1 if country is found
					NOT = { PREV = { is_variable_equal = { which = output_var value = -1 } } }
				}
				PREV = { core.export_var_to_prev = { VAR = output_var } }	# capital owner_id
				if = {
					limit = { is_variable_equal = { which = output_var which = country_id } }
					PREV = { set_variable = { which = output_var value = -1 } }	# break loop
					capital.changed_province = yes
				}
			}
			# Previous owner has been annexed/integrated
			# This can also point to an error if the owner exists but is not listed as a 'known_country'
			# but this shouldn't happen and would be a bug on Paradox's side
			#if = {
			#	limit = { NOT = { has_country_flag = territorial_change } }
			#	log = "EVE: Error 120 >> conquered capital [Root.GetName] with unknown previous owner."
			#}

			ROOT = {
				core.set_prov_owner_id = yes

				# Do not do anything further if this has already been done
				# by owner when checking for territorial change
				if = {
					limit = { NOT = { has_province_flag = conquered_capital } }
					autonomy.call_for_update = yes
					capital_scope = { core.fire_monthly_pulse = yes }
				}
				else = { clr_province_flag = conquered_capital }
			}
		}
		# Owner changed its capital province with diplomatic power or an event
		else = { capital.changed_province = yes }
	}
}

# Scope: country
# Assign id and enable monthly pulse for scoped country
# This is called in mod initialization phase and when a new country is formed
#
core.init_country = {

	if = {
		# can only be called once per country
		limit = { is_country_initialized = no }

		core.set_country_id = yes
		every_owned_province = {
			core.set_prov_owner_id = yes
		}

		capital.init = yes		# apply capital modifiers
		core.fire_monthly_pulse = yes    		# force an immediate update
		init_domestic_policies = yes

		set_country_flag = is_initialized
		set_country_flag = territorial_change
	}
}

# Scope: country
# Assign a unique id for scoped country
# This is called in mod initialization phase and when a new country is formed
# Should ONLY be called from global(player) scope!
#
core.set_country_id = {

	if = {
		limit = { PREV = { is_global_scope = yes } }

		PREV = { core.export_var_to_prev = { VAR = init_num } }
		set_variable = { which = country_id which = output_var }

		PREV = { change_variable = { which = init_num value = 1 } }
		change_variable = { which = country_id value = 1 }
	}
	else = { log = "EVE: Error 199 >> [This.GetName] called to set country_id out of global scope." }
}

# Scope: province
# Assign a unique id for province that coresponds to its owner country id
# Each owned province should ALWAYS have the same id as its current owner
#
core.set_prov_owner_id = {

	owner = {
		if = {
			limit = { check_variable = { which = country_id value = 1 } }
			core.export_var_to_prev = { VAR = country_id }
			PREV = { set_variable = { which = owner_id which = output_var } }
		}
		else = { owner = { log = "EVE: Error 279 >> 'country_id' var not initialized for country [This.GetName]." } }
	}
}

# Scope: country
# Export argument variable to PREV scope so it can be used for comparison.
# Currently using a while loop is the only way to transfer variable values between scopes.
# Here we are performing an interlaced scan with intervals using while loops.
# On average this method will run 20 rotations (changing var) per call
#
core.export_var_to_prev = {

	set_variable = { which = counter_var value = 1000 }
	PREV = { set_variable = { which = output_var value = 1000 } }

	# Do an interlaced scan alternating between adding and subtracting,
	# until we find an approximate value that we can use in a final loop

	while = {
		limit = {
			is_var_greater_than = { VAR1 = $VAR$ VAR2 = counter_var }
		}
		change_variable = { which = counter_var value = 1000 }
		PREV = { change_variable = { which = output_var value = 1000 } }
	}
	while = {
		limit = {
			is_var_less_than = { VAR1 = $VAR$ VAR2 = counter_var }
		}
		subtract_variable = { which = counter_var value = 100 }
		PREV = { subtract_variable = { which = output_var value = 100 } }
	}
	while = {
		limit = {
			is_var_greater_than = { VAR1 = $VAR$ VAR2 = counter_var }
		}
		change_variable = { which = counter_var value = 10 }
		PREV = { change_variable = { which = output_var value = 10 } }
	}

	while = {
		limit = { is_var_not_equal_to = { VAR1 = counter_var VAR2 = $VAR$ } }
		subtract_variable = { which = counter_var value = 1 }
		PREV = { subtract_variable = { which = output_var value = 1 } }
	}
}

##################################
# EVE - Capital Scripts
##################################

# Scope: country
# Called once after a country moves its capital to another province
#
capital.changed_province = {

	capital.init = yes
	set_country_flag = territorial_change
	core.fire_monthly_pulse = yes
}

# Scope: country
# Apply all capital modifiers in capital province for country scope
#
capital.init = {

	capital_scope = {
		add_province_triggered_modifier = capital_province
		add_province_modifier = { name = prov_nation_capital duration = -1 }
	}
}

# Scope: province
# Remove all capital modifiers from current province scope
#
capital.remove_modifiers = {

	if = {
		limit = { has_province_modifier = capital_province }

		remove_province_triggered_modifier = capital_province
		remove_province_modifier = prov_nation_capital
	}
	else = { log = "EVE: Error 309 >> tried to remove capital mods from non-capital province [This.GetName]" }
}

##################################
# EVE - Autonomy Scripts
##################################

# Scope: country
# Called on each monthly pulse to check if country gained new territory
# Note: this will also update owner id for each new province
#
autonomy.check_for_change = {

	# Check only for gained territory because lost territory doesn't
	# need an update from our side, the country that gained it will handle that

	every_owned_province = {

		# Gained territory is uncolonized land
		# For some reason each time a province becomes uncolonized it
		# loses all custom data, so we need to set 'owner_id' again
		if = {
			limit = { is_var_less_than_val = { VAR = owner_id VAL = 1 } }
			autonomy.call_for_update = yes
			core.set_prov_owner_id = yes
		}
		else = {
			# do this after handling uncolonized territory
			core.export_var_to_prev = { VAR = owner_id }

			if = {			# Newly gained province
				limit = {
					owner = { is_var_not_equal_to = { VAR1 = output_var VAR2 = country_id } }
				}

				# Conquered another nation's capital province
				# Raising the flag to let the province ROOT scope know we've already updated autonomy.
				# Also don't update owner id, it will be used by province ROOT scope to find last province owner
				if = {
					limit = { has_province_modifier = capital_province }
					set_province_flag = conquered_capital
				}
				else = { core.set_prov_owner_id = yes }	# update owner id

				clr_province_flag = distant_province	# don't try to remove modifier
				autonomy.call_for_update = yes		# call for an autonomy update
			}
		}
	}
}

# Scope: province
# Call for autonomy update only for this province
#
autonomy.call_for_update = {

	set_province_flag = new_territory		# update autonomy only for this province

	owner = {
		set_country_flag = territorial_change   	# call for autonomy update
		set_country_flag = gained_new_territory		# update only new territory
	}
}

# Scope: country
# Set local autonomy floor for every owned distance based on distance from capital
# Should ONLY be called from a provice with ROOT as that province
#
autonomy.update_distance = {

	if = {
		limit = { has_country_flag = gained_new_territory }
		every_owned_province = {
			limit = { has_province_flag = new_territory }
			autonomy.set_distance = yes
			clr_province_flag = new_territory
		}
		clr_country_flag = gained_new_territory
	}
	else = {
		every_owned_province = {
			autonomy.remove_distance_mod = yes
			autonomy.set_distance = yes
		}
	}
	clr_country_flag = territorial_change
}

# Scope: province
# Remove old distance modifier before applying a new one
# Called when recalculating province distance autonomy
#
autonomy.remove_distance_mod = {

	if = {
		limit = { has_province_flag = distant_province }
		trigger_switch = {
			on_trigger = has_province_modifier
			prov_autonomy_from_dist_50 = { remove_province_modifier = prov_autonomy_from_dist_50 }
			prov_autonomy_from_dist_100 = { remove_province_modifier = prov_autonomy_from_dist_100 }
			prov_autonomy_from_dist_150 = { remove_province_modifier = prov_autonomy_from_dist_150 }
			prov_autonomy_from_dist_200 = { remove_province_modifier = prov_autonomy_from_dist_200 }
			prov_autonomy_from_dist_250 = { remove_province_modifier = prov_autonomy_from_dist_250 }
			prov_autonomy_from_dist_300 = { remove_province_modifier = prov_autonomy_from_dist_300 }
			prov_autonomy_from_dist_350 = { remove_province_modifier = prov_autonomy_from_dist_350 }
		}
	}
}

# Scope: province
# Add autonomy modifiers based on province distance from capital
# Should ONLY be called from capital provinces (registered for monthly pulses)
#
autonomy.set_distance = {

	# will be removed if the province is not distant
	set_province_flag = distant_province

	if = {
		limit = { province_distance = { who = ROOT distance = 350 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_350" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 300 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_300" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 250 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_250" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 200 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_200" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 150 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_150" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 100 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_100" duration = -1 }
	}
	else_if = {
		limit = { province_distance = { who = ROOT distance = 50 } }
		add_province_modifier = { name = "prov_autonomy_from_dist_50" duration = -1 }
	}
	# province is in the capital zone and shouldn't have a distance modifier
	else = { clr_province_flag = distant_province }
}

##################################
# EVE - Domestic Policy Scripts
##################################

# Scope: country
# Initialize all domestic policies for country scope
#
init_domestic_policies = {

	init_gov_policy = yes
}

##################################
# EVE - Initialization Scripts
##################################

# Scope: country
# This method is called every time a new ruler rises to throne.
# We need to manually set variables like this because for unknown reasons
# exporting trigger values sometimes leads to a CTD.
#
export_ruler_skills = {
	trigger_switch = {
		on_trigger = adm
		5 = { set_variable = { which = ruler_adm_skill value = 5 } }
		4 = { set_variable = { which = ruler_adm_skill value = 4 } }
		3 = { set_variable = { which = ruler_adm_skill value = 3 } }
		2 = { set_variable = { which = ruler_adm_skill value = 2 } }
		1 = { set_variable = { which = ruler_adm_skill value = 1 } }
	}
	trigger_switch = {
		on_trigger = dip
		5 = { set_variable = { which = ruler_dip_skill value = 5 } }
		4 = { set_variable = { which = ruler_dip_skill value = 4 } }
		3 = { set_variable = { which = ruler_dip_skill value = 3 } }
		2 = { set_variable = { which = ruler_dip_skill value = 2 } }
		1 = { set_variable = { which = ruler_dip_skill value = 1 } }
	}
	trigger_switch = {
		on_trigger = mil
		5 = { set_variable = { which = ruler_mil_skill value = 5 } }
		4 = { set_variable = { which = ruler_mil_skill value = 4 } }
		3 = { set_variable = { which = ruler_mil_skill value = 3 } }
		2 = { set_variable = { which = ruler_mil_skill value = 2 } }
		1 = { set_variable = { which = ruler_mil_skill value = 1 } }
	}
}
